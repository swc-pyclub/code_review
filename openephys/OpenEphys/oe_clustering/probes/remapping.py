"""
Function to do the remapping
"""
import json
import numpy as np
import pandas as pd
from OpenEphys.oe_clustering.probes.remapping_database import *


def map_64chanprobe(physical_channel_order, probe_A64_disposition):
    """Given a physical channel order and a corresponding A64 channel dispostion, give the corresponding intan channels
    """
    check_map(physical_channel_order)
    check_map(probe_A64_disposition)
    map_list = np.zeros_like(physical_channel_order, dtype=int)
    for index, channel in enumerate(physical_channel_order):
        # find the position on the A64 of the CN electrode
        line, column = np.where(probe_A64_disposition == channel)
        # Reverse the column to go from male to female
        column = 3 - column
        # find which adaptor number correspond to that position
        adapt_chan = adt64_A64[line, column]
        # Find where than channel is on the omnetics side of the adaptor
        line, column = np.where(adt64_omn == adapt_chan)
        # Reverse the column to go from male to female
        column = adt64_omn.shape[1] - 1 - column
        # Find the number of the intan channel
        intan_chan = intan64[line, column]
        map_list[index] = int(intan_chan)
    return map_list


def check_map(mapping, n_chan=64):
    """Check that all channels are present one and only once"""
    mapping = np.asarray(mapping)
    # ignore the -1
    mapping = mapping[mapping != -1]
    n_val = pd.value_counts(mapping)
    if any(n_val != 1):
        print('BAD I have duplication issues')
        for i, count in enumerate(n_val):
            if count != 1:
                print('%d values for channel %d' % (count, n_val.index[i]))
    chans = np.arange(n_chan) + 1
    is_absent = [c not in n_val.index for c in chans]
    if any(is_absent):
        print('BAD I have missing values')
        print('Channels %s are missing.' % ' ,'.join([str(i) for i in chans[is_absent]]))


def read_oe_map_file(file_path):
    """Read a mapping file generated by openephys

    :param file_path:
    :return:
    """
    with open(file_path, 'r') as txt_file:
        data = json.load(txt_file)
    return data


def make_oe_map_file(file_path, chan_order, n_accelero, add_aos=True):
    """Create a text file that can be loaded by openephys as channel map
    """
    json_out = dict()

    # first make the main '0' dict

    main_dict = dict(mapping=chan_order,)
    json_out = dict(recording=dict(), refs=dict())

    raise NotImplementedError


"""
As a test example I use Chris niel electrode
"""
zero_based_CN_mapping_truth = np.array([48, 53, 55, 33, 50, 51, 57, 35, 52, 49, 60, 36, 54, 32, 62, 41,
                                        56, 34, 58, 45, 63, 37, 61, 38, 59, 39, 44, 42, 46, 43, 40, 47,
                                        11, 14, 31, 9, 13, 12, 29, 7, 15, 10, 26, 2, 30, 8, 23, 0,
                                        28, 6, 19, 4, 27, 1, 24, 3, 25, 5, 20, 18, 21, 16, 17, 22])
# check everything still works
chan_order_CN = map_64chanprobe(CN_physical, CN_A64)
bad = (np.array(chan_order_CN) - 1 - zero_based_CN_mapping_truth) != 0
assert not any(bad)

# Make an example with one H3 probe
# First find channel order
chan_order_H3 = map_64chanprobe(H3_physical, H3_A64)
chan_order_H2 = map_64chanprobe(H2_physical, H2_A64)

chan_order = np.concatenate([chan_order_H3, chan_order_CN + len(chan_order_H3)]) - 1
chan_order = np.concatenate([chan_order_CN, chan_order_H3 + len(chan_order_CN)]) - 1

chan_order = np.concatenate([chan_order_CN, chan_order_CN + len(chan_order_CN), chan_order_H2 + len(chan_order_CN)*2])
print('Done')
